{"version":3,"sources":["algorithms/bfs.js","Pathfinder/Pathfinder.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","prev","i","j","this","Pair","BFS","iLength","jLength","starti","startj","endi","endj","walls","searched","newgrid","createGrid","length","startCoords","endCoords","nodesToProcess","push","currentCoords","shift","getNeighbours","forEach","x","path","endNode","currentNodeCord","neighbours","top","isValid","right","bottom","left","y","grid","row","currentRow","col","GRID_LENGTH","Pathfinder","props","state","refresh","setState","elem","document","getElementsByClassName","style","backgroundColor","coordMap","wallCordsI","wallCordsJ","elems","result","index","delay","className","map","rowid","node","nodeid","onClick","setStartAndBegin","addWalls","bfs","React","Component","n","Promise","done","setTimeout","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a1ae560d.chunk.js","sourcesContent":["\r\nclass Node {\r\n    constructor(prev, i, j) {\r\n        this.prev = prev;\r\n        this.i = i;\r\n        this.j = j;\r\n    }\r\n}\r\n\r\nclass Pair {\r\n    constructor(i, j) {\r\n        this.i = i;\r\n        this.j = j;\r\n    }\r\n}\r\n\r\n\r\nexport const BFS = (iLength, jLength, starti, startj, endi, endj, walls) => {\r\n\r\n    \r\n\r\n    const searched = [];\r\n\r\n    let newgrid = createGrid(iLength,jLength);\r\n    // Setup walls\r\n    for (let i = 0; i < walls[0].length; i++) {\r\n        newgrid[walls[0][i]][walls[1][i]] = new Node(null,walls[0][i], walls[1][i]);\r\n    }\r\n    \r\n    let startCoords = new Pair(starti,startj);\r\n\r\n    let endCoords = new Pair(endi,endj);\r\n    \r\n    let nodesToProcess = [];\r\n    \r\n    nodesToProcess.push(startCoords);\r\n    \r\n    newgrid[startCoords.i][startCoords.j] = new Node(null, startCoords.i, startCoords.j);\r\n    // newgrid[endi - 1][endj] = new Node(null, startCoords.i, startCoords.j);\r\n    // newgrid[endi - 1][endj - 1] = new Node(null, startCoords.i, startCoords.j);\r\n\r\n    let currentCoords = new Pair();\r\n    while (!(currentCoords.i === endCoords.i && currentCoords.j === endCoords.j)) {\r\n    \r\n        \r\n        currentCoords = nodesToProcess.shift();\r\n        searched.push(currentCoords);\r\n        \r\n        let neighbours = [];\r\n        neighbours = getNeighbours(currentCoords, newgrid);\r\n        \r\n        neighbours.forEach(x => nodesToProcess.push(x));\r\n        \r\n\r\n    }\r\n    \r\n    let path = [];\r\n    let endNode = newgrid[currentCoords.i][currentCoords.j];\r\n    while (endNode != null) {\r\n        path.push(endNode);\r\n        endNode = endNode.prev;\r\n    }\r\n    // console.log(path);\r\n    return [path, searched];\r\n }\r\n \r\nexport const getNeighbours = (currentNodeCord, newgrid) => {\r\n\r\n    let neighbours = [];\r\n    let i = currentNodeCord.i;\r\n    let j = currentNodeCord.j;\r\n\r\n    // top\r\n    let top = new Pair(i-1, j);\r\n    if (isValid(newgrid, top.i, top.j)) {\r\n        neighbours.push(top);\r\n        newgrid[top.i][top.j] = new Node(newgrid[i][j],top.i, top.j);\r\n    }\r\n    // right\r\n    let right = new Pair(i, j+1);\r\n    if (isValid(newgrid, right.i, right.j)) {\r\n        neighbours.push(right);\r\n        newgrid[right.i][right.j] = new Node(newgrid[i][j], right.i, right.j);\r\n    }\r\n    // bottom\r\n    let bottom = new Pair(i+1, j);\r\n    if (isValid(newgrid, bottom.i, bottom.j)) {\r\n        neighbours.push(bottom);\r\n        newgrid[bottom.i][bottom.j] = new Node(newgrid[i][j], bottom.i, bottom.j);\r\n    }\r\n    // left\r\n    let left = new Pair(i, j - 1);\r\n    if (isValid(newgrid, left.i, left.j)) {\r\n        neighbours.push(left);\r\n        newgrid[left.i][left.j] = new Node(newgrid[i][j], left.i, left.j);\r\n        \r\n    }\r\n    return neighbours;\r\n}\r\n\r\nexport const isValid = (newgrid, x, y) => {\r\n\r\n    if (x < 0 || x >= newgrid.length ) return false;\r\n    if (y < 0 || y >= newgrid[0].length ) return false;\r\n    if (newgrid[x][y] != null) return false;\r\n    return true;\r\n}\r\n\r\nexport const createGrid = (iLength, jLength) => {\r\n    const grid = [];\r\n    for (let row = 0; row < iLength; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < jLength; col++) {\r\n            currentRow.push(null);\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}","import React from \"react\";\r\nimport { BFS } from \"../algorithms/bfs.js\";\r\n\r\nimport \"./pathfinder.css\";\r\n\r\nconst GRID_WIDTH = 30;\r\nconst GRID_LENGTH = 50;\r\n\r\nconst START_I = 5;\r\nconst START_J = 5;\r\nconst END_I = 15;\r\nconst END_J = 39;\r\n\r\nexport default class Pathfinder extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            grid: [],\r\n            walls: [],\r\n        \r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.refresh();\r\n    }\r\n\r\n    refresh() {\r\n        const grid = createGrid();\r\n        this.setState({grid});\r\n\r\n        const elem = document.getElementsByClassName(\"node\");\r\n        for (let i = 0; i < elem.length; i++) {\r\n            elem[i].style.backgroundColor = \"white\";\r\n        }\r\n    }\r\n    \r\n\r\n    setStartAndBegin() {\r\n        const elem = document.getElementsByClassName(\"node\");\r\n        elem[coordMap(START_I,START_J)].style.backgroundColor = \"green\";\r\n        elem[coordMap(END_I,END_J)].style.backgroundColor = \"red\";\r\n    }\r\n\r\n    addWalls() {\r\n        const wallCordsI = [];\r\n        const wallCordsJ = [];\r\n        const walls = [];\r\n        const elem = document.getElementsByClassName(\"node\");\r\n        let j = 20;\r\n        for (let i = 0; i < 25; i++) {\r\n            elem[coordMap(i, j)].style.backgroundColor = \"black\";\r\n            wallCordsI.push(i);\r\n            wallCordsJ.push(j);\r\n        }\r\n        walls.push(wallCordsI);\r\n        walls.push(wallCordsJ);\r\n        //this.state.walls = walls;\r\n        this.setState({walls});\r\n    }\r\n\r\n    async bfs() {\r\n        \r\n        const elems = document.getElementsByClassName(\"node\");\r\n        const walls = this.state.walls;\r\n        const result = BFS(GRID_WIDTH, GRID_LENGTH, START_I, START_J, END_I, END_J, walls);\r\n        const path = result[0];\r\n        const searched = result[1];\r\n        for (let i = 1; i < searched.length - 1; i++) {\r\n            let index = coordMap(searched[i].i, searched[i].j, GRID_LENGTH);\r\n            elems[index].style.backgroundColor = \"blue\";\r\n            await delay(10);\r\n        }\r\n        await delay(1);\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            let index = coordMap(path[i].i, path[i].j, GRID_LENGTH);\r\n            elems[index].style.backgroundColor = \"yellow\";\r\n        }\r\n        \r\n    }\r\n\r\n    render() {\r\n        const {grid} = this.state;\r\n        return (\r\n            <>\r\n                <div className=\"grid\">\r\n                        {grid.map((row, rowid) => (\r\n                            <div key={rowid} className=\"row\">\r\n                                {row.map((node, nodeid) => (\r\n                                    <div key={nodeid} className=\"node\"></div>\r\n                                ))}\r\n                            </div>\r\n                        ))}\r\n                </div>\r\n                <button onClick={() => this.setStartAndBegin()}>Set start and begin</button>\r\n                <button onClick={() => this.addWalls()}>Add walls</button>\r\n                <button onClick={() => this.bfs()}>bfs</button>\r\n                <button onClick={() => this.refresh()}>Refresh</button>\r\n            </>\r\n            \r\n        )\r\n        \r\n    }\r\n\r\n}\r\n\r\nfunction createGrid() {\r\n    const grid = [];\r\n    for (let row = 0; row < GRID_WIDTH; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < GRID_LENGTH; col++) {\r\n            currentRow.push(<div></div>);\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction coordMap(i , j) {\r\n    return i * GRID_LENGTH + j;\r\n}\r\n\r\nfunction delay(n) {  \r\n    n = n || 2000;\r\n    return new Promise(done => {\r\n      setTimeout(() => {\r\n        done();\r\n      }, n);\r\n    });\r\n  }","import Pathfinder from \"./Pathfinder/Pathfinder.jsx\"\n\nfunction App() {\n  return (\n    <Pathfinder>\n\n    </Pathfinder>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}